fus 1.3.1
import "./main" all

# Why default precision is 30ms? Because in most cases we don't want it to bring more CPU usage.
# In my test if it's 1ms then CPU usage will be around 5%. If 30ms then 0.4%.
# These two numbers are in single-core, so it's 1.25% and 0.1% in all my 4 cores.

# Why use one "global" `setInterval` to do checking? Because in my test, multiple `setInterval`
# or `setTimeout` are expensive. Here's the test result (both using 1ms interval):
# Single `setInterval`, callback has a 100000-cycle loop: 16% CPU usage
# 100 `setInterval`, callback is very simple: 13% CPU usage
# So, single `setInterval` is better. The real production will not reach 100000 cycles.

Timer'export: class
    static _endOfTime: new Date("9999-12-30T00:00:00Z")
    static _precision: 30

    static _enable: <>
        Me._internalTimer ifnull: setInterval(--
            Me._onCheck.fire()
        , Me._precision)
    static _disable: <>
        if Me._internalTimer'ok
            clearInterval(Me._internalTimer)
        Me._internalTimer: null

    static setPrecision: precision ->
        if Me._internalTimer'ok
            Me._disable()
            Me._precision: precision
            Me._enable()
        else
            Me._precision: precision
        void
    static getPrecision: ->
        Me._precision

    static _onCheck: eventField()

    constructor: options ->
        me.targetTime: options'ok.targetTime ifnull Me._endOfTime
        me.allowsEqual: options'ok.allowsEqual ifnull true
        me._counter: 0
        me._running: false
        me.onArrive: eventField()
        me.run()

    run: <>
        if not me._running
            me._running: true
            Me._enable()
            me._checker: <>
                nowTime: Date()
                if (me.allowsEqual ? nowTime â‰¥ me.targetTime | nowTime > me.targetTime)
                    me._counter: self + 1
                    lastTargetTime: me.targetTime
                    me.targetTime: Me._endOfTime
                    me.onArrive.fire{
                        idealTime: lastTargetTime
                        nowTime: nowTime
                        index: me._counter - 1
                    }
            Me._onCheck.bind(me._checker)
        me
    stop: <>
        if me._running
            me._running: false
            Me._onCheck.unbind(me._checker)
            if Me._onCheck.getListeners().isEmpty()
                Me._disable()
        me
    getRunning: <> me._running
    resetCounter: <>
        me._counter: 0
        me
    getCounter: <> me._counter

class Date.IntervalTimer extends Date.Timer
    constructor: (options) ->
        super(options)
        @interval = options?.interval ? 1000
        @startTime = options?.startTime ? new Date()
        @endTime = options?.endTime ? Date.Timer._endOfTime.subtract(1000)
        @includesStart = options?.includesStart ? true
        @includesEnd = options?.includesEnd ? false
        @skipsPast = options?.skipsPast ? false
        @targetTime = @startTime
        @_started = false
        @onStart = eventField()
        @onArrive.bind((event) =>
            if @interval < Date.Timer.getPrecision() * 2
                @stop()
                return
            now = new Date()
            @targetTime =
                if @skipsPast
                    now - (now - event.idealTime) % @interval + @interval
                else
                    event.idealTime.add(@interval)
            if not @_started
                @_started = true
                if not @includesStart
                    @resetCounter()
                    event.blocksListeners = true
                @onStart.fire()
            if (
                if @includesEnd
                    @targetTime > @endTime
                else
                    @targetTime >= @endTime
            )
                @stop()
        )

class Date.Observer extends Date.IntervalTimer
    @_error: new Error()
    constructor: ->
        [options, fun] =
            if typeof arguments[0] == "object"
                [arguments[0], arguments[1]]
            else
                [arguments[1], arguments[0]]
        clonedOptions = if options? then Object.clone(options) else {}
        clonedOptions.interval ?= 100
        clonedOptions.skipsPast ?= true
        super(clonedOptions)
        @_fun = fun
        @onChange = eventField()
        @onUpdate = eventField()
        @onArrive.bind(=>
            newValue =
                try
                    @_fun()
                catch
                    Date.Observer._error
            if newValue == undefined then newValue = Date.Observer._error

            # Must use `Object.is`, otherwise if NaN then the events will be fired endlessly.
            if @_oldValue == undefined or not Object.is(newValue, @_oldValue)
                @onUpdate.fire(value: newValue)
                if @_oldValue != undefined
                    @onChange.fire(
                        oldValue: @_oldValue
                        newValue: newValue
                    )
                @_oldValue = newValue
        )
