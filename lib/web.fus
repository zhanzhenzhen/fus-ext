fus 2.0.2, radical
import "./main" all

# According to RFC-7230, for HTTP response status we use "status reason"
# instead of status text or status message.

request'export: options -> Promise((resolve, reject) ->
    try
        method: options.method
        uri: options.uri
        headerFields: options.headerFields ifnull null
        body: options.body ifnull null
        timeout: options.timeout ifnull null
        responseBodyType: options.responseBodyType ifnull "text"
        if not method'ok
            fail()
        if not uri'ok
            fail()
        if body'ok and body isnt String and body isnt Uint8Array
            fail()
        if responseBodyType not in ["binary", "text", "json"]
            fail()
        if not sys.isNode then do --
            xhr: XMLHttpRequest()
            xhr.open(method, uri)
            if headerFields'ok
                Object..keyValues(headerFields).forEach([key, value] -> xhr.setRequestHeader(key, value))
            xhr.responseType:
                if responseBodyType = "binary"
                    "arraybuffer"
                else if responseBodyType = "text"
                    "text"
                else if responseBodyType = "json"
                    "text"
            xhr.timeout: timeout ifnull 0
            xhr.onload: <>
                response: {
                    statusCode: xhr.status
                    statusReason: xhr.statusText
                    headerFields:
                        xhr.getAllResponseHeaders()
                        ..stripTrailingNewline()
                        ..split("\r\n", ": ", 1)
                        .map(field -> [field.0.toLowerCase(), field.1])
                        ..toObject()
                    body:
                        if responseBodyType = "binary"
                            Uint8Array(xhr.response)
                        else if responseBodyType = "text"
                            xhr.response
                        else if responseBodyType = "json"
                            JSON.parse(xhr.response)
                }
                if (200 <= response.statusCode and response.statusCode < 300)
                    resolve(response)
                else
                    reject(response)
            xhr.onerror: <>
                reject(Error())
            xhr.ontimeout: <>
                reject(Error("timeout"))
            xhr.send(body)
        else do --
            http: module.require("http")
            https: module.require("https")
            urlMod: module.require("url")
            parsedUri: urlMod.parse(uri)
            httpOrHttps: parsedUri.protocol = "https:" ? https | http
            rawRequest: httpOrHttps.request(
                {
                    method: method
                    hostname: parsedUri.hostname
                    port: parsedUri.port
                    path: parsedUri.path
                    headers: headerFields
                },
                rawResponse ->
                    data: Buffer(0)
                    rawResponse.on("data", chunk ->
                        data: Buffer.concat[data, chunk]
                    )
                    rawResponse.on("end", <>
                        response: {
                            statusCode: rawResponse.statusCode
                            statusReason: rawResponse.statusMessage
                            headerFields: rawResponse.headers
                            body:
                                if responseBodyType = "binary"
                                    Uint8Array(data)
                                else if responseBodyType = "text"
                                    data.toString()
                                else if responseBodyType = "json"
                                    JSON.parse(data.toString())
                        }
                        if (200 <= response.statusCode and response.statusCode < 300)
                            resolve(response)
                        else
                            reject(response)
                    )
            )
            if timeout'ok
                rawRequest.setTimeout(timeout, <>
                    rawRequest.abort()
                    reject(Error("timeout"))
                )
            rawRequest.on("error", e ->
                reject(Error())
            ).end(body is Uint8Array ? Buffer(body) | body)
    catch ex
        reject(ex)
)

get'export: (uri, options) ->
    actualOptions: {
        method: "GET"
        uri: uri
    }
    Object.assign(actualOptions, options)
    web.request(actualOptions)

jsonGet'export: (uri, options) ->
    actualOptions: {
        method: "GET"
        uri: uri
        responseBodyType: "json"
    }
    Object.assign(actualOptions, options)
    web.request(actualOptions)

binaryGet'export: (uri, options) ->
    actualOptions: {
        method: "GET"
        uri: uri
        responseBodyType: "binary"
    }
    Object.assign(actualOptions, options)
    web.request(actualOptions)

post'export: (uri, body, options) ->
    actualOptions: {
        method: "POST"
        uri: uri
        body: body
    }
    Object.assign(actualOptions, options)
    web.request(actualOptions)

jsonPost'export: (uri, body, options) ->
    actualOptions: {
        method: "POST"
        uri: uri
        headerFields: {"Content-Type": "application/json"}
        body: JSON.stringify(body)
        responseBodyType: "json"
    }
    Object.assign(actualOptions, options)
    web.request(actualOptions)
