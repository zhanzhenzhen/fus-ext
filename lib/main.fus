fus 1.3.1, radical

internalLoop: (data, enablesReturns) ->
    theBreak: break # compatibility for embedded JS (`break` is a JS keyword)
    results: enablesReturns ? [] | void

    if data is Number
        js"
            (() => {
                for (let i = 0; i < data; i++) {
                    if (enablesReturns) results.push(i);
                }
                return results;
            })()
        "
    else if data is Function
        js"
            (() => {
                let i = 0;
                while (true) {
                    let r = data(i);
                    if (r === theBreak) break;
                    if (enablesReturns) results.push(r);
                    i++;
                }
                return results;
            })()
        "
    else if data is Array
        js"
            (() => {
                for (let i = 0; i < data[0]; i++) {
                    let r = data[1] === undefined ? i : data[1](i);
                    if (r === theBreak) break;
                    if (enablesReturns) results.push(r);
                }
                return results;
            })()
        "
    else if data is Object
        step: data.by ifvoid 1
        startIndex: data.from ifvoid data.""
        endIndex: data.to ifvoid Infinity
        js"
            (() => {
                for (let i = startIndex; step >= 0 ? i <= endIndex : i >= endIndex; i += step) {
                    let r = data.for === undefined ? i : data.for(i);
                    if (r === theBreak) break;
                    if (enablesReturns) results.push(r);
                }
                return results;
            })()
        "
    else
        throw Error("`repeat` syntax error.")

repeat'export: (a, b) -> internalLoop(b = void ? a | [a, b], true)
loop'export: (a, b) -> internalLoop(b = void ? a | [a, b], false)

break'export: Symbol()

enum'export: <>
    k: 0
    r: {}
    Object.keys(@).forEach <>
        r.(@): k
        k: k + 1
    r

fail'export: errorMessage -> throw Error(errorMessage)

compose'export: (functions...) ->
    functions: functions.0 if functions.0 is Array
    (args...) ->
        this: me
        functions.forEach(m ->
            args: [m.apply(this, args)]
        )
        args.0

assert'export: (condition, message) ->
    if not condition then fail(message)

spread'export: (value, count) ->
    repeat(count, -- value)

# This function `f` is weird and hard to understand, but we must use this mechanism
# (function+object hybrid) to support cascade (chaining).
# For chaining, I mean not `obj.onAbc.bind(a).unbind(a)`, but `obj.onAbc(a).onDef(b).doSth()`.
eventField'export: --
    f: (method, arg) ->
        if method is Function
            arg: method
            method: "bind"
        assert(method is String)
        f.(method)(arg)
        me
    f._listeners: []
    f.getListeners: --
        f._listeners..clone()
    f.bind: listener ->
        f._listeners.push(listener) if listener not in f._listeners
        f
    f.unbind: listener ->
        f._listeners..removeAll(listener)
        f
    f.unbindAll: --
        f._listeners: []
        f
    f.fire: arg ->
        f._listeners.every(listener ->
            if arg'ok.blocksListeners
                false
            else
                listener(arg)
                true
        )
        f
    f

# Timers ========================================[
# Why default precision is 30ms? Because in most cases we don't want it to bring more CPU usage.
# In my test if it's 1ms then CPU usage will be around 5%. If 30ms then 0.4%.
# These two numbers are in single-core, so it's 1.25% and 0.1% in all my 4 cores.

# Why use one "global" `setInterval` to do checking? Because in my test, multiple `setInterval`
# or `setTimeout` are expensive. Here's the test result (both using 1ms interval):
# Single `setInterval`, callback has a 100000-cycle loop: 16% CPU usage
# 100 `setInterval`, callback is very simple: 13% CPU usage
# So, single `setInterval` is better. The real production will not reach 100000 cycles.

Timer'export: class
    static _endOfTime: new Date("9999-12-30T00:00:00Z")
    static _precision: 30

    static _enable: <>
        Me._internalTimer ifnull: setInterval(--
            Me._onCheck.fire()
        , Me._precision)
    static _disable: <>
        if Me._internalTimer'ok
            clearInterval(Me._internalTimer)
        Me._internalTimer: null

    static setPrecision: precision ->
        if Me._internalTimer'ok
            Me._disable()
            Me._precision: precision
            Me._enable()
        else
            Me._precision: precision
        void
    static getPrecision: <>
        Me._precision

    static getEndOfTime: <>
        Me._endOfTime

    static _onCheck: eventField()

    new: options ->
        me.targetTime: options'ok.targetTime ifnull Me._endOfTime
        me.allowsEqual: options'ok.allowsEqual ifnull true
        me._counter: 0
        me._running: false
        me.onArrive: eventField()
        me.run()

    run: <>
        if not me._running
            me._running: true
            Me._enable()
            me._checker: <>
                nowTime: Date()
                if (me.allowsEqual ? nowTime ≥ me.targetTime | nowTime > me.targetTime)
                    me._counter: self + 1
                    lastTargetTime: me.targetTime
                    me.targetTime: Me._endOfTime
                    me.onArrive.fire{
                        idealTime: lastTargetTime
                        nowTime: nowTime
                        index: me._counter - 1
                    }
            Me._onCheck.bind(me._checker)
        me
    stop: <>
        if me._running
            me._running: false
            Me._onCheck.unbind(me._checker)
            if Me._onCheck.getListeners()..isEmpty()
                Me._disable()
        me
    getRunning: <> me._running
    resetCounter: <>
        me._counter: 0
        me
    getCounter: <> me._counter

IntervalTimer'export: class from Timer
    new: options ->
        super(options)
        me.interval: options'ok.interval ifnull 1000
        me.startTime: options'ok.startTime ifnull Date()
        me.endTime: options'ok.endTime ifnull Me.getEndOfTime()..subtract(1000)
        me.includesStart: options'ok.includesStart ifnull true
        me.includesEnd: options'ok.includesEnd ifnull false
        me.skipsPast: options'ok.skipsPast ifnull false
        me.targetTime: me.startTime
        me._started: false
        me.onStart: eventField()
        me.onArrive.bind(event ->
            if me.interval < Me.getPrecision() * 2
                me.stop()
            else
                now: Date()
                me.targetTime:
                    if me.skipsPast
                        now - (now - event.idealTime) rem me.interval + me.interval
                    else
                        event.idealTime..add(me.interval)
                if not me._started
                    me._started: true
                    if not me.includesStart
                        me.resetCounter()
                        event.blocksListeners: true
                    me.onStart.fire()
                if (
                    if me.includesEnd
                        me.targetTime > me.endTime
                    else
                        me.targetTime ≥ me.endTime
                )
                    me.stop()
        )

Observer'export: class from IntervalTimer
    static _error: Error()
    new: (args...) ->
        [options, fn]: args.0 is Function ? [args.1, args.0] | [args.0, args.1]
        clonedOptions: options'ok ? Object..clone(options) | {}
        clonedOptions.interval ifnull: 100
        clonedOptions.skipsPast ifnull: true
        super(clonedOptions)
        me._fun: fn
        me.onChange: eventField()
        me.onUpdate: eventField()
        me.onArrive.bind(<>
            newValue:
                try
                    me._fun()
                catch
                    Me._error
            if newValue = void
                newValue: Me._error

            # Must use `Object.is`, otherwise if NaN then the events will be fired endlessly.
            if me._oldValue = void or not Object.is(newValue, me._oldValue)
                me.onUpdate.fire{value: newValue}
                if me._oldValue ≠ void
                    me.onChange.fire{
                        oldValue: me._oldValue
                        newValue: newValue
                    }
                me._oldValue: newValue
        )

# ]========================================

sys: import "./sys" all
export sys

web: import "./web" all
export web

feNumber: import "./number" all
export feNumber

feNumberStatic: import "./number-static" all
export feNumberStatic

feString: import "./string" all
export feString

feObject: import "./object" all
export feObject

feArray: import "./array" all
export feArray

feMath: import "./math" all
export feMath

feJson: import "./json" all
export feJson

feDate: import "./date" all
export feDate

feConsole: import "./console" all
export feConsole

..'export: x ->
    if x = Number
        feNumberStatic
    else if x = Object
        feObject
    else if x = Math
        feMath
    else if x = JSON
        feJson
    else if x = console
        feConsole
    else if x is Number
        feNumber
    else if x is String
        feString
    else if x is Array
        feArray
    else if x is Date
        feDate
