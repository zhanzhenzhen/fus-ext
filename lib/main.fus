fus 1.2.0, radical

internalLoop: [data, enablesReturns] ->
    theBreak: break # compatibility for embedded JS (`break` is a JS keyword)
    results: enablesReturns ? [] | void

    if data is Number
        js"
            (() => {
                for (let i = 0; i < data; i++) {
                    if (enablesReturns) results.push(i);
                }
                return results;
            })()
        "
    else if data is Function
        js"
            (() => {
                let i = 0;
                while (true) {
                    let r = data(i);
                    if (r === theBreak) break;
                    if (enablesReturns) results.push(r);
                    i++;
                }
                return results;
            })()
        "
    else if data is Array
        js"
            (() => {
                for (let i = 0; i < data[0]; i++) {
                    let r = data[1] === undefined ? i : data[1](i);
                    if (r === theBreak) break;
                    if (enablesReturns) results.push(r);
                }
                return results;
            })()
        "
    else if data is Object
        step: data.by ifvoid 1
        startIndex: data.from ifvoid data.""
        endIndex: data.to ifvoid Infinity
        js"
            (() => {
                for (let i = startIndex; step >= 0 ? i <= endIndex : i >= endIndex; i += step) {
                    let r = data.for === undefined ? i : data.for(i);
                    if (r === theBreak) break;
                    if (enablesReturns) results.push(r);
                }
                return results;
            })()
        "
    else
        throw Error("`repeat` syntax error.")

repeat'export: (a, b) -> internalLoop[b = void ? a | [a, b], true]
loop'export: (a, b) -> internalLoop[b = void ? a | [a, b], false]

break'export: Symbol()

enum'export: <>
    k: 0
    r: {}
    Object.keys(@).forEach <>
        r.(@): k
        k: k + 1
    r

fail'export: errorMessage -> throw Error(errorMessage)

compose'export: (functions...) ->
    functions: functions.0 if functions.0 is Array
    (args...) ->
        this: me
        functions.forEach(m ->
            args: [m.apply(this, args)]
        )
        args.0

assert'export: (condition, message) ->
    [condition, message]: condition if condition is Array
    if not condition then fail(message)

spread'export: (value, count) ->
    [value, count]: value if count = void
    repeat[count, -- value]

sys: import "./sys" all
export sys

web: import "./web" all
export web

es: import "./string" all
export es

ea: import "./array" all
export ea
